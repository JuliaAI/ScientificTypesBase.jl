# -----------------------------------------------------------------------------------------
# This file introduces `scitype`, `Scitype` methods and associated fallbacks methods.
# It also defines some conveneince methods.
# -----------------------------------------------------------------------------------------

# -----------------------------------------------------------------------------------------
# scitype function (generic) with fallbacks.


# helper to print a type hierarchy:
function print_type_tree(io, T, level=0)
    println(io, "  " ^ level, T)
    for S in subtypes(T)
        print_type_tree(io, S, level + 1)
    end
end

"""
    scitype(;io=stdout)

Print to `io` the scitype hierarchy, beginning at `Found` (and so excluding `Missing` and
`Nothing`).

Note that third party packages can extend the hierarchy, so output is not static.

"""
scitype(; io=stdout) = print_type_tree(io, Found)

"""
    scitype(X, C::Convention)

The scientific type (interpretation) of object `X` (distinct from its
machine type) as specified by the convention 'C'.
"""
function scitype end

scitype(X, C::Convention) = fallback_scitype(X, C)
fallback_scitype(X, C) = Unknown
fallback_scitype(::Missing, C) = Missing
fallback_scitype(::Nothing, C) = Nothing

# -----------------------------------------------------------------------------------------
# `Scitype` function (generic) with fallbacks.
# (When implemented can considerably speed-up computation of `scitype` of abstractarrays.)

"""
    Scitype(T::Type, C::Convention)

Method for implementers of a convention `C` to enable speed-up of
scitype evaluations for arrays.

In general, one cannot infer the scitype of an object of type
`AbstractArray{T, N}` from the machine type `T` alone.

Nevertheless, for some *restricted* machine types `U`, the statement
`type(X) == AbstractArray{T, N}` for some `T<:U` already allows one
deduce that `scitype(X, C) = AbstractArray{S, N}`, where `S` is determined
by `U`, and convention `C` alone. This is the case in the `DefaultConvention` which is
used by *ScientificTypes.jl* , where for example, if `U = Integer`, then `S = Count`.

Such shortcuts are specified as follows:

```
Scitype(::Type{<:U}, ::C) = S
```

which incurs a considerable speed-up in the computation of `scitype(X, C)`.
There is also a speed-up for the case that `T <: Union{U, Missing}`.

For example, in the `DefaultConvention`, one has

```
Scitype(::Type{<:Integer}, ::DefaultConvention) = Count
```
"""
function Scitype end

Scitype(T, C::Convention) = Fallback_Scitype(T, C)
Fallback_Scitype(::Type, C) = Unknown

# To distinguish between `Any` type and `Union{T, Missing}` for some more
# specialised `T`, we define the `Any` case explicitly.
Fallback_Scitype(::Type{Any}, C) = Unknown

# For the case `Union{T, Missing}` we return `Union{S, Missing}` with `S`
# the scientific type corresponding to `T`.
function Fallback_Scitype(::Type{Union{T, Missing}}, C) where T
    return Union{Scitype(Missing, C), Scitype(T, C)}
end

# For the case `Missing` and `Nothing`,
# we return `Missing` and `Nothing` respectively.
Fallback_Scitype(::Type{Missing}, C) = Missing
Fallback_Scitype(::Type{Nothing}, C) = Nothing

# ---------------------------------------------------------------------------------------
# Fallbacks for `scitype` of tuples and abstractarrays.

function fallback_scitype(@nospecialize(t::Tuple), C)
    if length(t) <= TUPLE_SPECIALIZATION_THRESHOLD
        return _tuple_scitype(t, C)
    else
        return Tuple{(scitype(el, C) for el in t)...}
    end
end

@inline function _tuple_scitype(t::T, C) where {T}
    if @generated
        stypes = Tuple(
            :(scitype(getindex(t, $i), C)) for i in 1:fieldcount(T)
        )
        return :(Tuple{$(stypes...)})
    else
        stypes_ = Tuple(
            scitype(getindex(t, i), C) for i in 1:fieldcount(T)
        )
        return Tuple{(stypes_)...}
    end
end

function fallback_scitype(A::Arr{T}, C) where T
    return arr_scitype(A, Scitype(T, C), C)
end

"""
    arr_scitype(A, S, C)

Return the scitype associated with an  array `A` of type `{T, N}` assuming an
explicit `Scitype` correspondence exist mapping `T` to `S`.
"""
@inline function arr_scitype(
    @nospecialize(A::Arr{T, N}), S::Type, C;
    tight::Bool = false
) where {T, N}
    if S === Unknown
        return Arr{scitype_union(A, C), N}
    elseif S === Union{Scitype(Missing, C), Unknown}
        return Arr{Union{Scitype(Missing, C), scitype_union(A, C)}, N}
    else
        return Arr{S, N}
    end
end

# -----------------------------------------------------------------------------------------
# internal methods.

"""
    scitype_union(A, C::convention)

Return the type union, over all elements `x` generated by the iterable `A`,
of `scitype(x, C)` for a given convention `C`. See also [`scitype`](@ref).
"""
function scitype_union(A, C::Convention)
    iterate(A) === nothing && return Unknown
    reduce((a, b)->Union{a, b}, (scitype(el, C) for el in A))
end
