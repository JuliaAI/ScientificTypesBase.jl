# -----------------------------------------------------------------------------------------
# This file introduces `scitype`, `Scitype` methods and associated fallbacks methods. 
# It also defines some conveneince methods.
# -----------------------------------------------------------------------------------------

# -----------------------------------------------------------------------------------------
# scitype function (generic) with fallbacks.
"""
    scitype(X, C::Convention)

The scientific type (interpretation) of object `X` (distinct from its
machine type) as specified by the convention 'C'.
"""
function scitype end

scitype(X, C::Convention; kw...) = fallback_scitype(X, C; kw...)
fallback_scitype(X, C; kw...) = Unknown
fallback_scitype(::Missing, C; kw...) = Missing
fallback_scitype(::Nothing, C; kw...) = Nothing

# -----------------------------------------------------------------------------------------
# `Scitype` function (generic) with fallbacks.
# (When implemented can considerably speed-up computation of `scitype` of abstractarrays.)

"""
    Scitype(T::Type, C::Convention)

Method for implementers of a convention `C` to enable speed-up of
scitype evaluations for arrays.

In general, one cannot infer the scitype of an object of type
`AbstractArray{T, N}` from the machine type `T` alone.

Nevertheless, for some *restricted* machine types `U`, the statement
`type(X) == AbstractArray{T, N}` for some `T<:U` already allows one
deduce that `scitype(X, C) = AbstractArray{S, N}`, where `S` is determined
by `U`, and convention `C` alone. This is the case in the `DefaultConvention` which is 
used by *ScientificTypes.jl* , where for example, if `U = Integer`, then `S = Count`.

Such shortcuts are specified as follows:

```
Scitype(::Type{<:U}, ::C) = S
```

which incurs a considerable speed-up in the computation of `scitype(X, C)`.
There is also a speed-up for the case that `T <: Union{U, Missing}`.

For example, in the `DefaultConvention`, one has

```
Scitype(::Type{<:Integer}, ::DefaultConvention) = Count
```
"""
function Scitype end

Scitype(T, C::Convention) = Fallback_Scitype(T, C)
Fallback_Scitype(::Type, C) = Unknown

# To distinguish between `Any` type and `Union{T, Missing}` for some more
# specialised `T`, we define the `Any` case explicitly.
Fallback_Scitype(::Type{Any}, C) = Unknown

# For the case `Union{T, Missing}` we return `Union{S, Missing}` with `S`
# the scientific type corresponding to `T`.
function Fallback_Scitype(::Type{Union{T, Missing}}, C) where T
    return Union{Scitype(Missing, C), Scitype(T, C)}
end

# For the case `Missing` and `Nothing`, 
# we return `Missing` and `Nothing` respectively.
Fallback_Scitype(::Type{Missing}, C) = Missing
Fallback_Scitype(::Type{Nothing}, C) = Nothing

# ---------------------------------------------------------------------------------------
# Fallbacks for `scitype` of tuples and abstractarrays.

function fallback_scitype(@nospecialize(t::Tuple), C; kw...)
    if length(t) <= TUPLE_SPECIALIZATION_THRESHOLD
        return _tuple_scitype(t, C; kw...)
    else
        return Tuple{(scitype(el, C; kw...) for el in t)...}
    end
end

@inline function _tuple_scitype(t::T, C; kw...) where {T}
    if @generated
        stypes = Tuple(
            :(scitype(getindex(t, $i), C; kw...)) for i in 1:fieldcount(T)
        )
        return :(Tuple{$(stypes...)})
    else
        stypes_ = Tuple(
            scitype(getindex(t, i), C; kw...) for i in 1:fieldcount(T)
        )
        return Tuple{(stypes_)...}
    end
end

function fallback_scitype(A::Arr{T}, C; kw...) where T
    return arr_scitype(A, Scitype(T, C), C; kw...)
end

"""
    arr_scitype(A, S, C; tight)

Return the scitype associated with an  array `A` of type `{T, N}` assuming an
explicit `Scitype` correspondence exist mapping `T` to `S`.
If `tight=true` and `T>:Missing` then the function checks whether there are
"true missing values", otherwise it returns the scitype asscoiated with a 
"tight copy" of the array.
**Note**
The eltype of a "tight_copy" of an array with eltype `Union{T, Missing}` is `T`  
"""
@inline function arr_scitype(
    @nospecialize(A::Arr{T, N}), S::Type, C;
    tight::Bool = false
) where {T, N}
    if T >: Missing && tight
        has_missings = findfirst(ismissing, A) !== nothing
        _S = !has_missings ? Scitype(nonmissing(T), C) : S
    else
        _S = S
    end

    return _take_scitype_union_if_needed(A, _S, C)
end

function _take_scitype_union_if_needed(A::Arr{T, N}, S::Type, C) where {T, N}
    if S === Unknown
        return Arr{scitype_union(A, C), N}
    elseif S === Union{Scitype(Missing, C), Unknown}
        return Arr{Union{Scitype(Missing, C), scitype_union(A, C)}, N}
    else    
        return Arr{S, N}
    end
end

# -----------------------------------------------------------------------------------------
# Convenience methods.

"""
    scitype_union(A, C::convention)

Return the type union, over all elements `x` generated by the iterable `A`,
of `scitype(x, C)` for a given convention `C`. See also [`scitype`](@ref).
"""
function scitype_union(A, C::Convention)
    iterate(A) === nothing && return Unknown
    reduce((a, b)->Union{a, b}, (scitype(el, C) for el in A))
end

"""
    elscitype(A, C::Convention)

Return the element scientific type of an abstract array `A` as specified by 
convention `C`. By definition, if `scitype(A, C) = AbstractArray{S, N}`, then
`elscitype(A, C) = S`.
"""
elscitype(X::Arr, C::Convention; kw...) = eltype(scitype(X, C; kw...))